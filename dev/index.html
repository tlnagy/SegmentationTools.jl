<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Segment cells with Julia · SegmentationTools.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SegmentationTools.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Segment cells with Julia</a><ul class="internal"><li><a class="toctext" href="#Flow-1">Flow</a></li><li><a class="toctext" href="#Segmentation-1">Segmentation</a></li><li><a class="toctext" href="#Linking-1">Linking</a></li><li><a class="toctext" href="#Analysis-and-Plotting-1">Analysis and Plotting</a></li><li><a class="toctext" href="#Miscellaneous-1">Miscellaneous</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Segment cells with Julia</a></li></ul><a class="edit-page" href="https://github.com/tlnagy/SegmentationTools.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Segment cells with Julia</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Segment-cells-with-Julia-1" href="#Segment-cells-with-Julia-1">Segment cells with Julia</a></h1><p>Welcome to SegmentationTools.jl! This is a random collection of functions that I&#39;ve implemented for segmenting single cells from microscopy images.</p><h2><a class="nav-anchor" id="Flow-1" href="#Flow-1">Flow</a></h2><p>The general procedure follows the following format:</p><p>Segmentation -&gt; Linking -&gt; Analysis</p><h2><a class="nav-anchor" id="Segmentation-1" href="#Segmentation-1">Segmentation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SegmentationTools.segment_cells" href="#SegmentationTools.segment_cells"><code>SegmentationTools.segment_cells</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">segment_cells(img, seed_channel, segment_channel, maskfunc)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tlnagy/SegmentationTools.jl/blob/5bf421b35b1f3b25ccee78cb9d9ff5fd886f199d/src/segment.jl#L4-L6">source</a></section><h2><a class="nav-anchor" id="Linking-1" href="#Linking-1">Linking</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SegmentationTools.build_tp_df" href="#SegmentationTools.build_tp_df"><code>SegmentationTools.build_tp_df</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">build_tp_df(img, segments, signal_channel)</code></pre><p>Build a <code>DataFrames.DataFrame</code> that is compatible with trackpys <code>link_df</code> function. Needs to be converted to a <code>Pandas.DataFrame</code> before passing</p></div></div><a class="source-link" target="_blank" href="https://github.com/tlnagy/SegmentationTools.jl/blob/5bf421b35b1f3b25ccee78cb9d9ff5fd886f199d/src/segment.jl#L46-L51">source</a></section><p>I generally use it like so:</p><pre><code class="language-julia">particles = SegmentationTools.build_tp_df(img1, segments, :EPI_mNG);
using PyCall
tp = pyimport(&quot;trackpy&quot;)

import Pandas
# convert particles to a Pandas DataFrame and call trackpy
t = tp.link_df(Pandas.DataFrame(particles), 5);
linked = DataFrame(Pandas.DataFrame(t)); # convert back to Julian dataframe</code></pre><h2><a class="nav-anchor" id="Analysis-and-Plotting-1" href="#Analysis-and-Plotting-1">Analysis and Plotting</a></h2><p>It&#39;s often helpful to look at each cell quickly to validate the tracking and segmentation, which is where <a href="#SegmentationTools.create_cell_grid"><code>create_cell_grid</code></a> comes in handy. Let&#39;s create a XYT image that we&#39;ve segmented and tracked.</p><p>The <code>tracks</code> dataframe should have the following columns (<code>trackpy</code> outputs these by default):</p><ul><li><code>x</code>, <code>y</code>: the centroid coordinates</li><li><code>frame</code>: the time index</li><li><code>id</code>: the per-frame id that can vary over the time course.</li><li><code>particle</code>: a persistent <code>id</code> that is the same across all time points for a given particle. <code>trackpy</code> links up the different <code>id</code>s into one <code>particle</code> value.</li></ul><pre><code class="language-julia">using ImageShow
using DataFrames
using Colors
using SegmentationTools

img = zeros(Int, 25, 45, 1)
xs = 11:12:35
img[13, xs, 1] .= [1,2,3] # three equidistant dots
tracks = DataFrame(y=13, x=xs, frame=1:3, particle=1:3, id=1:3)
Gray.(img[:, :, 1]./4.0)</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIcAAABLCAAAAAB/pssZAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAABBSURBVGje7dDBDcAgDANA08nKZmxWRusG4QkSd19bUeQEAAAAAO7V6vhN5urESMaq8yW9LDy7hzjsDwAAAAC42Q/qUAMGtoFnhgAAAABJRU5ErkJggg==" /><p>The corresponding cell grid will have the <code>particle</code> id displayed in the upper right corner and show the time course of the movie with the particle&#39;s centroid centered in the grid cell.</p><pre><code class="language-julia">result = SegmentationTools.create_cell_grid(img, tracks, win=10)
Gray.(result[:, :, 1])</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAACEAQAAAAB5P74KAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QAAd2KE6QAAAB/SURBVEjH7dTBCcAgDAXQX7x3goIrdgRH8+YajuAABUtsQ8GTyUFS8F/EdzBEMcAJypauttJ2QFx5JPogEM/iJMLV4wGNZI0kqKQGieCt/p1jT+gVmmSJWOtiiRGpXcqQ8EyQCf+4GeKKRrDPE+Ud4gfS5o9YrHWxxIjULkNyA6nqDk0utMBhAAAAAElFTkSuQmCC" /><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SegmentationTools.create_cell_grid" href="#SegmentationTools.create_cell_grid"><code>SegmentationTools.create_cell_grid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">create_cell_grid(img, tracks; win) -&gt; grid</code></pre><p>Given a xyt image and set of tracks, creates a grid of all tracked cells with the cells centered in their grid location. Helps to quickly diagnose weird cell  segmentation behavior.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tlnagy/SegmentationTools.jl/blob/5bf421b35b1f3b25ccee78cb9d9ff5fd886f199d/src/diagnostics.jl#L1-L7">source</a></section><h2><a class="nav-anchor" id="Miscellaneous-1" href="#Miscellaneous-1">Miscellaneous</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SegmentationTools.find_peak_center" href="#SegmentationTools.find_peak_center"><code>SegmentationTools.find_peak_center</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">find_peak_center(x, y, h)</code></pre><p>Given two equal length arrays, <code>x</code>, and <code>y</code>, computes the half width  at <code>h</code> relative to the maximum of the peak in <code>y</code>, i.e. for <code>h=0.5</code>, this  function returns the value of <code>x</code> that corresponds to the half-width  half-max. This is a robust method for identifying the center of a peak.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tlnagy/SegmentationTools.jl/blob/5bf421b35b1f3b25ccee78cb9d9ff5fd886f199d/src/utils.jl#L102-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SegmentationTools.light_source_contrib" href="#SegmentationTools.light_source_contrib"><code>SegmentationTools.light_source_contrib</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">light_source_contrib(img, seeds, dist, h)</code></pre><p>Computes the contribution of the light source fluctuations for each time point by first identifying background pixels by finding pixels that are more than <code>dist</code> away from true values in <code>seeds</code>. A kernel density estimate is then fit to the background pixels to get a continuous distribution and then <a href="#SegmentationTools.find_peak_center"><code>find_peak_center</code></a> is used to identify the &quot;average&quot; response of a background pixel.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The distribution of background pixels often ends up being quite non-normal, likely due to misidentification. Empirically, I&#39;ve found the finding the center of the kernel  density estimate to be more robust than simpler statistics like mean, median, or even the maximum value of the KDE.</p></div></div><p><strong>Rationale</strong></p><p>Certain light sources, especially arc lamps, exhibit substantial variance in  total brightness in time. Additionally, the background signal is dependent on the total light delivered and we can use that to identify the arc lamp wander and subtract it from the whole field of view at each timestep. This gives us more stable total fluorescence values over time.</p><p><strong>Example:</strong></p><pre><code class="language-julia">a = img[Axis{:position}(2), Axis{:channel}(:EPI_mNG)].data
b = img[Axis{:position}(2), Axis{:channel}(:EPI_BFP)].data .&gt; 0.01
SegmentationTools.light_source_contrib(a, b)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tlnagy/SegmentationTools.jl/blob/5bf421b35b1f3b25ccee78cb9d9ff5fd886f199d/src/utils.jl#L51-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SegmentationTools.flatfield_correct" href="#SegmentationTools.flatfield_correct"><code>SegmentationTools.flatfield_correct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">flatfield_correct(img, axis, darkfield, flatfield)</code></pre><p>Flatfield correct <code>img</code>. This function subtracts the darkfield, clamps the output to positive values, divides by the flatfield, and then rescales and rebuilds the original image perserving the properties and axes.</p><p>For example, to correct along the DAPI channel:</p><pre><code class="language-none">flatfield_correct(img[Axis{:channel}(:EPI_DAPI)], darkfield, flatfield_dapi)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tlnagy/SegmentationTools.jl/blob/5bf421b35b1f3b25ccee78cb9d9ff5fd886f199d/src/utils.jl#L21-L33">source</a></section><footer><hr/></footer></article></body></html>
