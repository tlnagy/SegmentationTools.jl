var documenterSearchIndex = {"docs":
[{"location":"#Segment-cells-with-Julia-1","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"","category":"section"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"Welcome to SegmentationTools.jl! This is a random collection of functions that I've implemented for segmenting single cells from microscopy images.","category":"page"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"CurrentModule=SegmentationTools","category":"page"},{"location":"#Flow-1","page":"Segment cells with Julia","title":"Flow","text":"","category":"section"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"The general procedure follows the following format:","category":"page"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"Segmentation -> Linking -> Analysis","category":"page"},{"location":"#Segmentation-1","page":"Segment cells with Julia","title":"Segmentation","text":"","category":"section"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"SegmentationTools.segment_cells","category":"page"},{"location":"#SegmentationTools.segment_cells","page":"Segment cells with Julia","title":"SegmentationTools.segment_cells","text":"segment_cells(img, seed_channel, segment_channel, maskfunc)\n\n\n\n\n\n","category":"function"},{"location":"#Linking-1","page":"Segment cells with Julia","title":"Linking","text":"","category":"section"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"SegmentationTools.build_tp_df","category":"page"},{"location":"#SegmentationTools.build_tp_df","page":"Segment cells with Julia","title":"SegmentationTools.build_tp_df","text":"build_tp_df(img, thresholds; dist)\n\nBuild a DataFrames.DataFrame that is compatible with trackpys link_df function. Needs to be converted to a Pandas.DataFrame before passing to trackpy. dist is a 2-tuple of integers indicating the minimum and maximum distance away in pixels from each cell to include in its local background calculation.\n\n\n\n\n\nGiven an img with at least y, x, and t axes and a 3 dimensional boolean array, thresholds, in yxt order.\n\n\n\n\n\n","category":"function"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"I generally use it like so:","category":"page"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"particles = SegmentationTools.build_tp_df(img, thresholds);\nusing PyCall\ntp = pyimport(\"trackpy\")\n\nimport Pandas\n# convert particles to a Pandas DataFrame and call trackpy\nt = tp.link_df(Pandas.DataFrame(particles), 5);\nlinked = DataFrame(Pandas.DataFrame(t)); # convert back to Julian dataframe","category":"page"},{"location":"#Analysis-and-Plotting-1","page":"Segment cells with Julia","title":"Analysis and Plotting","text":"","category":"section"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"It's often helpful to look at each cell quickly to validate the tracking and segmentation, which is where create_cell_grid comes in handy. Let's create a XYT image that we've segmented and tracked.","category":"page"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"The tracks dataframe should have the following columns (trackpy outputs these by default):","category":"page"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"x, y: the centroid coordinates\nframe: the time index\nid: the per-frame id that can vary over the time course.\nparticle: a persistent id that is the same across all time points for a given particle. trackpy links up the different ids into one particle value.","category":"page"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"using ImageShow\nusing DataFrames\nusing Colors\nusing SegmentationTools\n\nimg = zeros(Int, 25, 45, 1)\nxs = 11:12:35\nimg[13, xs, 1] .= [1,2,3] # three equidistant dots\ntracks = DataFrame(y=13, x=xs, frame=1:3, particle=1:3, id=1:3)\nGray.(img[:, :, 1]./4.0)","category":"page"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"The corresponding cell grid will have the particle id displayed in the upper right corner and show the time course of the movie with the particle's centroid centered in the grid cell.","category":"page"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"result = SegmentationTools.create_cell_grid(img, tracks, win=10)\nGray.(result[:, :, 1])","category":"page"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"SegmentationTools.create_cell_grid","category":"page"},{"location":"#SegmentationTools.create_cell_grid","page":"Segment cells with Julia","title":"SegmentationTools.create_cell_grid","text":"create_cell_grid(img, tracks; win) -> grid\n\nGiven a xyt image and set of tracks, creates a grid of all tracked cells with the cells centered in their grid location. Helps to quickly diagnose weird cell  segmentation behavior.\n\n\n\n\n\n","category":"function"},{"location":"#Observing-cell-localities-1","page":"Segment cells with Julia","title":"Observing cell localities","text":"","category":"section"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"For low signal-to-noise applications, it can be useful to compute the local background to normalize against. The nonexported function, SegmentationTools._get_locality_mask, can be used to display the localities used in SegmentationTools.build_tp_df to diagnose any weird behaviors.","category":"page"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"using FileIO, Images, SegmentationTools\nslice = FileIO.load(\"https://user-images.githubusercontent.com/1661487/64392405-81a30500-d001-11e9-8262-744f76ff2f69.png\")\ncomponents = label_components(Bool.(slice))\nforeground = components .> 0.0\nlocals = Array{RGB{Float64}, 2}[]\ngold = RGB((255,215,0)./255...)\norchid = RGB((186,85,211)./255...)\nfor i in 1:maximum(components)\n    mask = components .== i\n    result = RGB(0.5, 0.5, 0.5) .* foreground\n    result .+= gold .* (Float64.(SegmentationTools._get_locality_mask(mask, foreground, dist=(10, 60))))\n    result[mask] .= orchid\n    push!(locals, result)\nend\nreshape(locals, (:, 6))","category":"page"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"SegmentationTools._get_locality_mask","category":"page"},{"location":"#SegmentationTools._get_locality_mask","page":"Segment cells with Julia","title":"SegmentationTools._get_locality_mask","text":"_get_locality_mask(cell_mask, foreground; dist=(mindist, maxdist))\n\nGiven a boolean matrix of the pixels belonging to a single cell,\n\ncell_mask, and a boolean matrix of foreground pixels, foreground, this function  identifies the local background ring around the cell that is at minimum mindist away from every cell and a maximum of maxdist away from the target cell.\n\n\n\n\n\n","category":"function"},{"location":"#Miscellaneous-1","page":"Segment cells with Julia","title":"Miscellaneous","text":"","category":"section"},{"location":"#","page":"Segment cells with Julia","title":"Segment cells with Julia","text":"SegmentationTools.find_peak_center\nSegmentationTools.light_source_contrib\nSegmentationTools.flatfield_correct","category":"page"},{"location":"#SegmentationTools.find_peak_center","page":"Segment cells with Julia","title":"SegmentationTools.find_peak_center","text":"find_peak_center(x, y, h)\n\nGiven two equal length arrays, x, and y, computes the half width at h relative to the maximum of the peak in y, i.e. for h=0.5, this function returns the value of x that corresponds to the half-width half-max. This is a robust method for identifying the center of a peak.\n\n\n\n\n\n","category":"function"},{"location":"#SegmentationTools.light_source_contrib","page":"Segment cells with Julia","title":"SegmentationTools.light_source_contrib","text":"light_source_contrib(img, seeds, dist, h)\n\nComputes the contribution of the light source fluctuations for each time point by first identifying background pixels by finding pixels that are more than dist away from true values in seeds. A kernel density estimate is then fit to the background pixels to get a continuous distribution and then find_peak_center is used to identify the \"average\" response of a background pixel.\n\nnote: Note\nThe distribution of background pixels often ends up being quite non-normal, likely due to misidentification. Empirically, I've found the finding the center of the kernel density estimate to be more robust than simpler statistics like mean, median, or even the maximum value of the KDE.\n\nRationale\n\nCertain light sources, especially arc lamps, exhibit substantial variance in total brightness in time. Additionally, the background signal is dependent on the total light delivered and we can use that to identify the arc lamp wander and subtract it from the whole field of view at each timestep. This gives us more stable total fluorescence values over time.\n\nExample:\n\na = img[Axis{:position}(2), Axis{:channel}(:EPI_mNG)].data\nb = img[Axis{:position}(2), Axis{:channel}(:EPI_BFP)].data .> 0.01\nSegmentationTools.light_source_contrib(a, b)\n\n\n\n\n\n","category":"function"},{"location":"#SegmentationTools.flatfield_correct","page":"Segment cells with Julia","title":"SegmentationTools.flatfield_correct","text":"flatfield_correct(img, flatfield, darkfield)\n\nComputes the flatfield for the given image img by dividing the image by the flatfield after subtracting the darkfield from both[1]\n\nnote: Note\nThis function assumes that the flatfield image has not had the darkfield image subtracted yet.\n\n[1]: http://nic.ucsf.edu/resources/how-to-acquire-flat-field-correction-images/\n\n\n\n\n\n","category":"function"}]
}
